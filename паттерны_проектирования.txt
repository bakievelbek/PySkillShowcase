Паттерны проектирования обычно делят на три основные категории:
1. Порождающие паттерны (Creational Patterns)

Эти паттерны облегчают процесс создания объектов, делая систему независимой от способа создания, компоновки и
представления объектов. Порождающие паттерны скрывают сложность создания экземпляров, делая код более гибким при
добавлении новых типов объектов.

    Одиночка (Singleton): Гарантирует, что класс имеет только один экземпляр, и предоставляет к нему глобальную точку
    доступа.
    Фабричный метод (Factory Method): Определяет интерфейс для создания объекта, но позволяет подклассам изменять
    тип создаваемых объектов.
    Абстрактная фабрика (Abstract Factory): Позволяет создавать семейства связанных объектов, не специфицируя их
    конкретные классы.
    Строитель (Builder): Позволяет создавать сложные объекты пошагово.
    Прототип (Prototype): Позволяет копировать объекты, не вдаваясь в подробности их реализации.

2. Структурные паттерны (Structural Patterns)

Структурные паттерны описывают способы компоновки объектов для формирования более крупных структур, облегчая тем
самым проектирование сложных систем.

    Адаптер (Adapter): Позволяет объектам с несовместимыми интерфейсами работать вместе.
    Мост (Bridge): Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.
    Компоновщик (Composite): Позволяет считать одиночные объекты и составные объекты одинаковыми.
    Декоратор (Decorator): Добавляет новые обязанности объектам без изменения их интерфейса.
    Фасад (Facade): Предоставляет единый интерфейс к группе интерфейсов системы.
    Приспособленец (Flyweight): Минимизирует использование памяти или вычислительных ресурсов, разделяя одинаковые
    данные между множеством объектов.
    Заместитель (Proxy): Предоставляет объект-заместитель, который контролирует доступ к другому объекту.

3. Поведенческие паттерны (Behavioral Patterns)

Поведенческие паттерны занимаются эффективной коммуникацией и распределением обязанностей между объектами.

    Цепочка обязанностей (Chain of Responsibility): Позволяет передавать запросы последовательно по цепочке обработчиков.
    Команда (Command): Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить
    запросы в очередь, логировать их и поддерживать отмену операций.
    Итератор (Iterator): Предоставляет способ последовательного доступа к элементам объекта-агрегата без раскрытия его
     внутреннего представления.
    Посредник (Mediator): Уменьшает сложность коммуникации между объектами, позволяя им не ссылаться друг на друга
    напрямую.
    Наблюдатель (Observer): Позволяет объектам получать уведомления об изменении состояния других объектов.

    Состояние (State): Позволяет объекту изменять свое поведение при изменении внутреннего состояния.
    Стратегия (Strategy): Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их
    взаимозаменяемость.
    Шаблонный метод (Template Method): Определяет скелет алгоритма, перекладывая ответственность за некоторые его
    шаги на подклассы.
    Посетитель (Visitor): Позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми
    эти операции могут выполняться.